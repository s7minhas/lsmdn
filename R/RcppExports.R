# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Draw from Metropolis Hasting acceptance probability for Gamma^2, for non-negative continuous data
#' @param X  an n x p x T array of latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of X
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param alph Shape parameter for Gamma^2 value
#' @param bta Scale parameter for Gamma^2 value
#' @param ww vector of weights/radius
#' @param g2 current value of Gamma^2
#' @param g2new proposed new value of Gamma^2
#' @return returns list of starting values:
#' \item{g2New}{new g2 value}
#' \item{AccRate}{updated accRate}
#' @export
gammaAccProb <- function(X, dims, Y, BIN, BOUT, alph, bta, ww, g2, g2new) {
    .Call('lsmdn_gammaAccProb', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, alph, bta, ww, g2, g2new)
}

#' Draw from Metropolis Hasting acceptance probability for Gamma^2, for continuous data
#' @param X  an n x p x T array of latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of X
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param alph Shape parameter for Gamma^2 value
#' @param bta Scale parameter for Gamma^2 value
#' @param ww vector of weights/radius
#' @param g2 current value of Gamma^2
#' @param g2new proposed new value of Gamma^2
#' @return returns new value for Gamma^2 and updated acceptance rate:
#' \item{g2New}{new g2 value}
#' \item{AccRate}{updated accRate}
#' @export
gammaAccProbGaussian <- function(X, dims, Y, BIN, BOUT, alph, bta, ww, g2, g2new) {
    .Call('lsmdn_gammaAccProbGaussian', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, alph, bta, ww, g2, g2new)
}

#' Impute missing values in Y for binary data
#' @param X  an n x p x T array of latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of X
#' @param MM n x n x T array with 1s where Y is missing
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param Ttt time period value
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param ww vector of weights/radius
#' @return Y with imputed values
#' @export
imputeMissingBinomial <- function(X, dims, MM, Y, Ttt, BIN, BOUT, ww) {
    .Call('lsmdn_imputeMissingBinomial', PACKAGE = 'lsmdn', X, dims, MM, Y, Ttt, BIN, BOUT, ww)
}

#' Impute missingness in Y for continuous data
#' @param X  an n x p x T array of latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of X
#' @param MM n x n x T array with 1s where Y is missing
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param Ttt time period value
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param ww vector of weights/radius
#' @return Y with imputed values
#' @export
imputeMissingGaussian <- function(X, dims, MM, Y, Ttt, BIN, BOUT, ww, g2) {
    .Call('lsmdn_imputeMissingGaussian', PACKAGE = 'lsmdn', X, dims, MM, Y, Ttt, BIN, BOUT, ww, g2)
}

#' Impute missingness in Y for Count Data
#' @param X  an n x p x T array of latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of X
#' @param MM n x n x T array with 1s where Y is missing
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param Ttt time period value
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param ww vector of weights/radius
#' @return Y with imputed values
#' @export
imputeMissingPoisson <- function(X, dims, MM, Y, Ttt, BIN, BOUT, ww) {
    .Call('lsmdn_imputeMissingPoisson', PACKAGE = 'lsmdn', X, dims, MM, Y, Ttt, BIN, BOUT, ww)
}

#' initialize beta values for binomial data
#' @param X n x p x T array of initial values for the latent space
#' @param dims vector of dimentions for X
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param Xscale 1/n where n is the number of actors
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param ww vector of radiuses/weights
#' @export
initializeBinom <- function(X, dims, Y, Xscale, BIN, BOUT, ww) {
    .Call('lsmdn_initializeBinom', PACKAGE = 'lsmdn', X, dims, Y, Xscale, BIN, BOUT, ww)
}

#' initialize beta values for binomial data using a conjugate gradient method
#' @param X n x p x T array of initial values for the latent space
#' @param dims vector of dimentions for X
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param Xscale 1/n where n is the number of actors
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param ww vector of radiuses/weights
#' @export
initializeBinomGrad <- function(X, dims, Y, Xscale, BIN, BOUT, ww) {
    .Call('lsmdn_initializeBinomGrad', PACKAGE = 'lsmdn', X, dims, Y, Xscale, BIN, BOUT, ww)
}

#' Posterior zero prob
#' @param xi1 matrix
#' @param xi2 matrix
#' @param xj1 matrix
#' @param xj2 matrix
#' @param ss2 vector
#' @param lam
#' @param pp0
#' @return stuff
#' @export
postZeroProb <- function(xi1, xi2, xj1, xj2, ss2, lam, pp0) {
    .Call('lsmdn_postZeroProb', PACKAGE = 'lsmdn', xi1, xi2, xj1, xj2, ss2, lam, pp0)
}

#' get get predicted values for Y with binary data
#' @param Ex matrix of expected positions for X at time T
#' @param sig2 vector of values for sigma^2 from different iterations
#' @param x1 matrix of values for the first dimension of X from different iterations
#' @param x2 matrix of values for the second dimention of X from different iterations
#' @param Bin  vector of values for betaIn from different iterations
#' @param Bout  vector of values for betaOut from different iterations
#' @param ww  matrix of weights/radii from different iterations
#' @return Matrix with expected values of Y
#' @export
predictionBinomial <- function(Ex, sig2, x1, x2, Bin, Bout, ww) {
    .Call('lsmdn_predictionBinomial', PACKAGE = 'lsmdn', Ex, sig2, x1, x2, Bin, Bout, ww)
}

#' get get predicted values for Y with continuous data
#' @param Ex matrix of expected positions for X at time T
#' @param sig2 vector of values for sigma^2 from different iterations
#' @param x1 matrix of values for the first dimension of X from different iterations
#' @param x2 matrix of values for the second dimention of X from different iterations
#' @param Bin  vector of values for betaIn from different iterations
#' @param Bout  vector of values for betaOut from different iterations
#' @param ww  matrix of weights/radii from different iterations
#' @return Matrix with expected values of Y
#' @export
predictionGaussian <- function(Ex, sig2, x1, x2, Bin, Bout, ww) {
    .Call('lsmdn_predictionGaussian', PACKAGE = 'lsmdn', Ex, sig2, x1, x2, Bin, Bout, ww)
}

#' get get predicted values for Y with count data
#' @param Ex matrix of expected positions for X at time T
#' @param sig2 vector of values for sigma^2 from different iterations
#' @param x1 matrix of values for the first dimension of X from different iterations
#' @param x2 matrix of values for the second dimention of X from different iterations
#' @param Bin  vector of values for betaIn from different iterations
#' @param Bout  vector of values for betaOut from different iterations
#' @param ww  matrix of weights/radii from different iterations
#' @return Matrix with expected values of Y
#' @export
predictionPoisson <- function(Ex, sig2, x1, x2, Bin, Bout, ww) {
    .Call('lsmdn_predictionPoisson', PACKAGE = 'lsmdn', Ex, sig2, x1, x2, Bin, Bout, ww)
}

#' generate shape and scale parameters to update t2 and s2 for all types of data
#' @param X  an n x p x T array of latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of X
#' @param thetaT shape parameter for t
#' @param thetaS shape parameter for s
#' @param phiT scale parameter for t
#' @param phiS scale parameter for s
#' @return returns list of:
#' \item{shapeT}{Shape Parameter for $\tau^2$}
#' \item{scaleT}{Scale Parameter for $\tau^2$}
#' \item{shapeS}{Shape Parameter for $\sigma^2$}
#' \item{scaleS}{Scale Parameter for $\sigma^2$}
#' @export
t2s2Parms <- function(X, dims, thetaT, thetaS, phiT, phiS) {
    .Call('lsmdn_t2s2Parms', PACKAGE = 'lsmdn', X, dims, thetaT, thetaS, phiT, phiS)
}

#' update lat positions, beta params, and accrate for binomial data
#' @param Xitm1 an n x p x T array of the current latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of Xitm1
#' @param tunex Variance of the normal random walk proposal for the latent space
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneBIO Variance of the normal random walk proposal for betaIn and betaOut
#' @param ww vector of radius/weights
#' @param t2 variance of initial latent positions
#' @param s2 variance of change in latent positions
#' @param xiBin mean of prior for betaIn
#' @param xiBout mean of prior for betaOut
#' @param nuBin variance of prior for betaIn
#' @param nuBout variance of prior for betaOut
#' @param Cauchy use a cauchy proposal or not
#' @param rnormsVec Vector of noise for random walks for X
#' @param rnormsBIO Vector of noise for random walks for betaIn/betaOut
#' @return returns list of:
#' \item{Xnew}{New array of latent positions}
#' \item{BinNew}{New values for $\beta_{IN}$}
#' \item{BoutNew}{New values for $\beta_{OUT}}
#' \item{AccRate}{Updated acceptance rate}
#' @export
updateBinom <- function(Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO) {
    .Call('lsmdn_updateBinom', PACKAGE = 'lsmdn', Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO)
}

#' update lat positions, beta params, and accrate for binomial data with a LL approximation
#' @param Xitm1 an n x p x T array of the current latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of Xitm1
#' @param tunex Variance of the normal random walk proposal for the latent space
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneBIO Variance of the normal random walk proposal for betaIn and betaOut
#' @param ww vector of radius/weights
#' @param t2 variance of initial latent positions
#' @param s2 variance of change in latent positions
#' @param xiBin mean of prior for betaIn
#' @param xiBout mean of prior for betaOut
#' @param nuBin variance of prior for betaIn
#' @param nuBout variance of prior for betaOut
#' @param Cauchy use a cauchy proposal or not
#' @param rnormsVec Vector of noise for random walks for X
#' @param rnormsBIO Vector of noise for random walks for betaIn/betaOut
#' @param ELout array
#' @param ELin array
#' @param subseq matrix
#' @param degr array
#' @return returns list of:
#' \item{Xnew}{New array of latent positions}
#' \item{BinNew}{New values for $\beta_{IN}$}
#' \item{BoutNew}{New values for $\beta_{OUT}}
#' \item{AccRate}{Updated acceptance rate}
#' @export
updateBinomLogLikeApprox <- function(Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO, ELout, ELin, subseq, degr) {
    .Call('lsmdn_updateBinomLogLikeApprox', PACKAGE = 'lsmdn', Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO, ELout, ELin, subseq, degr)
}

#' update lat positions, beta params, and accrate for continuous data
#' @param Xitm1 an n x p x T array of the current latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of Xitm1
#' @param tunex Variance of the normal random walk proposal for the latent space
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneBIO Variance of the normal random walk proposal for betaIn and betaOut
#' @param ww vector of radius/weights
#' @param t2 variance of initial latent positions
#' @param s2 variance of change in latent positions
#' @param g2 variance of eta
#' @param xiBin mean of prior for betaIn
#' @param xiBout mean of prior for betaOut
#' @param nuBin variance of prior for betaIn
#' @param nuBout variance of prior for betaOut
#' @param Cauchy use a cauchy proposal or not
#' @param rnormsVec Vector of noise for random walks for X
#' @param rnormsBIO Vector of noise for random walks for betaIn/betaOut
#' @return returns list of:
#' \item{Xnew}{New array of latent positions}
#' \item{BinNew}{New values for $\beta_{IN}$}
#' \item{BoutNew}{New values for $\beta_{OUT}}
#' \item{AccRate}{Updated acceptance rate}
#' @export
updateGaussian <- function(Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, g2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO) {
    .Call('lsmdn_updateGaussian', PACKAGE = 'lsmdn', Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, g2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO)
}

#' update lat positions, beta params, and accrate for non-negative continuous data
#' @param Xitm1 an n x p x T array of the current latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of Xitm1
#' @param tunex Variance of the normal random walk proposal for the latent space
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneBIO Variance of the normal random walk proposal for betaIn and betaOut
#' @param ww vector of radius/weights
#' @param t2 variance of initial latent positions
#' @param s2 variance of change in latent positions
#' @param g2 variance of eta
#' @param xiBin mean of prior for betaIn
#' @param xiBout mean of prior for betaOut
#' @param nuBin variance of prior for betaIn
#' @param nuBout variance of prior for betaOut
#' @param Cauchy use a cauchy proposal or not
#' @param rnormsVec Vector of noise for random walks for X
#' @param rnormsBIO Vector of noise for random walks for betaIn/betaOut
#' @return returns list of:
#' \item{Xnew}{New array of latent positions}
#' \item{BinNew}{New values for $\beta_{IN}$}
#' \item{BoutNew}{New values for $\beta_{OUT}}
#' \item{AccRate}{Updated acceptance rate}
#' @export
updateNonNegNorm <- function(Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, g2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO) {
    .Call('lsmdn_updateNonNegNorm', PACKAGE = 'lsmdn', Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, g2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO)
}

#' update lat positions, beta params, and accrate for count data
#' @param Xitm1 an n x p x T array of the current latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of Xitm1
#' @param tunex Variance of the normal random walk proposal for the latent space
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneBIO Variance of the normal random walk proposal for betaIn and betaOut
#' @param ww vector of radius/weights
#' @param t2 variance of initial latent positions
#' @param s2 variance of change in latent positions
#' @param xiBin mean of prior for betaIn
#' @param xiBout mean of prior for betaOut
#' @param nuBin variance of prior for betaIn
#' @param nuBout variance of prior for betaOut
#' @param Cauchy use a cauchy proposal or not
#' @param rnormsVec Vector of noise for random walks for X
#' @param rnormsBIO Vector of noise for random walks for betaIn/betaOut
#' @return returns list of:
#' \item{Xnew}{New array of latent positions}
#' \item{BinNew}{New values for $\beta_{IN}$}
#' \item{BoutNew}{New values for $\beta_{OUT}}
#' \item{AccRate}{Updated acceptance rate}
#' @export
updatePoisson <- function(Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO) {
    .Call('lsmdn_updatePoisson', PACKAGE = 'lsmdn', Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO)
}

#' update weights and accprob for non-negative normal data
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @param g2
#' @return returns list of:
#' \item{wwNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
wAccProb_nnn <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2) {
    .Call('lsmdn_wAccProb_nnn', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2)
}

#' update weights and accprob for binary data
#' @param X  an n x p x T array of latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of X
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW variance of the proposal distribution for w
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @return returns list of:
#' \item{wwNew}{New weights/radius}
#' \item{AccRate}{Updated acceptance probability}
#' @export
wAccProbBinom <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew) {
    .Call('lsmdn_wAccProbBinom', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew)
}

#' update weights and accprob for continuous normal data
#' @param X  an n x p x T array of latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of X
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW variance of the proposal distribution for w
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @param g2 Variance of eta
#' @return returns list of:
#' \item{wwNew}{New weights/radius}
#' \item{AccRate}{Updated acceptance probability}
#' @export
wAccProbGaussian <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2) {
    .Call('lsmdn_wAccProbGaussian', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2)
}

#' update weights and accprob for binomial data using log-likelihood approximation
#' @param X  an n x p x T array of latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of X
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW variance of the proposal distribution for w
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @param ELout array
#' @param ELin array
#' @param subseq matrix
#' @param degr array
#' @return returns list of:
#' \item{wwNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
wAccProb_llApprox <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, ELout, ELin, subseq, degr) {
    .Call('lsmdn_wAccProb_llApprox', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, ELout, ELin, subseq, degr)
}

#' update weights and accprob for non-negative continuous normal data
#' @param X  an n x p x T array of latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of X
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW variance of the proposal distribution for w
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @param g2 Variance of eta
#' @return returns list of:
#' \item{wwNew}{New weights/radius}
#' \item{AccRate}{Updated acceptance probability}
#' @export
wAccProbNonNegNormal <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2) {
    .Call('lsmdn_wAccProbNonNegNormal', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2)
}

#' update weights and accprob for count data
#' @param X  an n x p x T array of latent coordinates, where the second dimension is the number dimensions of the latent space, and the third is time 
#' @param dims vector of dimensions of X
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW variance of the proposal distribution for w
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @return returns list of:
#' \item{wwNew}{New weights/radius}
#' \item{AccRate}{Updated acceptance probability}
#' @export
wAccProbPoisson <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew) {
    .Call('lsmdn_wAccProbPoisson', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew)
}

