# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Draw from inv gamma and adjust acceptance rate, for non-negative normal data
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param alph
#' @param bta
#' @param ww vector of weights
#' @param g2 current value
#' @param g2new new value
#' @return returns list of starting values:
#' \item{g2New}{new g2 value}
#' \item{AccRate}{updated accRate}
#' @export
gammaAccProb <- function(X, dims, Y, BIN, BOUT, alph, bta, ww, g2, g2new) {
    .Call('lsmdn_gammaAccProb', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, alph, bta, ww, g2, g2new)
}

#' Draw from inv gamma and adjust acceptance rate, for non-negative normal data
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param alph
#' @param bta
#' @param ww vector of weights
#' @param g2 current value
#' @param g2new new value
#' @return returns list of starting values:
#' \item{g2New}{new g2 value}
#' \item{AccRate}{updated accRate}
#' @export
gammaAccProbGaussian <- function(X, dims, Y, BIN, BOUT, alph, bta, ww, g2, g2new) {
    .Call('lsmdn_gammaAccProbGaussian', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, alph, bta, ww, g2, g2new)
}

#' Impute missingness in Y
#' @param X data cube
#' @param dims vector of dims
#' @param MM 
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param Ttt
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param ww vector of weights
#' @return Y with imputed values
#' @export
imputeMissingBinomial <- function(X, dims, MM, Y, Ttt, BIN, BOUT, ww) {
    .Call('lsmdn_imputeMissingBinomial', PACKAGE = 'lsmdn', X, dims, MM, Y, Ttt, BIN, BOUT, ww)
}

#' Impute missingness in Y
#' @param X data cube
#' @param dims vector of dims
#' @param MM 
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param Ttt
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param ww vector of weights
#' @return Y with imputed values
#' @export
imputeMissingGaussian <- function(X, dims, MM, Y, Ttt, BIN, BOUT, ww, g2) {
    .Call('lsmdn_imputeMissingGaussian', PACKAGE = 'lsmdn', X, dims, MM, Y, Ttt, BIN, BOUT, ww, g2)
}

#' Impute missingness in Y
#' @param X data cube
#' @param dims vector of dims
#' @param MM 
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param Ttt
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param ww vector of weights
#' @return Y with imputed values
#' @export
imputeMissingPoisson <- function(X, dims, MM, Y, Ttt, BIN, BOUT, ww) {
    .Call('lsmdn_imputeMissingPoisson', PACKAGE = 'lsmdn', X, dims, MM, Y, Ttt, BIN, BOUT, ww)
}

#' initialize beta values for binomial data
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param Xscale
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param ww vector of weights
#' @export
initializeBinom <- function(X, dims, Y, Xscale, BIN, BOUT, ww) {
    .Call('lsmdn_initializeBinom', PACKAGE = 'lsmdn', X, dims, Y, Xscale, BIN, BOUT, ww)
}

#' initialize beta values for binomial data using gradient
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param Xscale
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param ww vector of weights
#' @export
initializeBinomGrad <- function(X, dims, Y, Xscale, BIN, BOUT, ww) {
    .Call('lsmdn_initializeBinomGrad', PACKAGE = 'lsmdn', X, dims, Y, Xscale, BIN, BOUT, ww)
}

#' Posterior zero prob
#' @param xi1 matrix
#' @param xi2 matrix
#' @param xj1 matrix
#' @param xj2 matrix
#' @param ss2 vector
#' @param lam
#' @param pp0
#' @return stuff
#' @export
postZeroProb <- function(xi1, xi2, xj1, xj2, ss2, lam, pp0) {
    .Call('lsmdn_postZeroProb', PACKAGE = 'lsmdn', xi1, xi2, xj1, xj2, ss2, lam, pp0)
}

#' get predictions for yhat
#' @param Ex matrix
#' @param sig2 vector
#' @param x1 matrix
#' @param x2 matrix
#' @param Bin betaIn vector
#' @param Bout betaOut vector
#' @param ww weights matrix
#' @return yhat
#' @export
predictionBinomial <- function(Ex, sig2, x1, x2, Bin, Bout, ww) {
    .Call('lsmdn_predictionBinomial', PACKAGE = 'lsmdn', Ex, sig2, x1, x2, Bin, Bout, ww)
}

#' get predictions for yhat
#' @param Ex matrix
#' @param sig2 vector
#' @param x1 matrix
#' @param x2 matrix
#' @param Bin betaIn vector
#' @param Bout betaOut vector
#' @param ww weights matrix
#' @return yhat
#' @export
predictionGaussian <- function(Ex, sig2, x1, x2, Bin, Bout, ww) {
    .Call('lsmdn_predictionGaussian', PACKAGE = 'lsmdn', Ex, sig2, x1, x2, Bin, Bout, ww)
}

#' get predictions for yhat
#' @param Ex matrix
#' @param sig2 vector
#' @param x1 matrix
#' @param x2 matrix
#' @param Bin betaIn vector
#' @param Bout betaOut vector
#' @param ww weights matrix
#' @return yhat
#' @export
predictionPoisson <- function(Ex, sig2, x1, x2, Bin, Bout, ww) {
    .Call('lsmdn_predictionPoisson', PACKAGE = 'lsmdn', Ex, sig2, x1, x2, Bin, Bout, ww)
}

#' update t2 and s2
#' @param X data cube
#' @param dims vector of dims
#' @param thetaT shape parameter for t
#' @param thetaS shape parameter for s
#' @param phiT scale parameter for t
#' @param phiS scale parameter for s
#' @return returns list of:
#' \item{shapeT}{add desc}
#' \item{scaleT}{add desc}
#' \item{shapeS}{add desc}
#' \item{scaleS}{add desc}
#' @export
t2s2Parms <- function(X, dims, thetaT, thetaS, phiT, phiS) {
    .Call('lsmdn_t2s2Parms', PACKAGE = 'lsmdn', X, dims, thetaT, thetaS, phiT, phiS)
}

#' update lat positions, beta params, and accrate for binomial data
#' @param Xitm1 data cube
#' @param dims vector of dims
#' @param tunex
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneBIO
#' @param ww vector of weights
#' @param t2
#' @param s2
#' @param xiBin
#' @param xiBout
#' @param nuBin
#' @param nuBout
#' @param Cauchy
#' @param rnormsVec vector
#' @param rnormsBIO vector
#' @return returns list of:
#' \item{Xnew}{add desc}
#' \item{BinNew}{add desc}
#' \item{BoutNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
updateBinom <- function(Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO) {
    .Call('lsmdn_updateBinom', PACKAGE = 'lsmdn', Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO)
}

#' update lat positions, beta params, and accrate for binomial data using log-likelihood approximation
#' @param Xitm1 data cube
#' @param dims vector of dims
#' @param tunex
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneBIO
#' @param ww vector of weights
#' @param t2
#' @param s2
#' @param xiBin
#' @param xiBout
#' @param nuBin
#' @param nuBout
#' @param Cauchy
#' @param rnormsVec vector
#' @param rnormsBIO vector
#' @param ELout array
#' @param ELin array
#' @param subseq matrix
#' @param degr array
#' @return returns list of:
#' \item{Xnew}{add desc}
#' \item{BinNew}{add desc}
#' \item{BoutNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
updateBinomLogLikeApprox <- function(Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO, ELout, ELin, subseq, degr) {
    .Call('lsmdn_updateBinomLogLikeApprox', PACKAGE = 'lsmdn', Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO, ELout, ELin, subseq, degr)
}

#' update lat positions, beta params, and accrate for non-negative normal data
#' @param Xitm1 data cube
#' @param dims vector of dims
#' @param tunex
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneBIO
#' @param ww vector of weights
#' @param t2
#' @param s2
#' @param g2
#' @param xiBin
#' @param xiBout
#' @param nuBin
#' @param nuBout
#' @param Cauchy
#' @param rnormsVec vector
#' @param rnormsBIO vector
#' @return returns list of:
#' \item{Xnew}{add desc}
#' \item{BinNew}{add desc}
#' \item{BoutNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
updateGaussian <- function(Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, g2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO) {
    .Call('lsmdn_updateGaussian', PACKAGE = 'lsmdn', Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, g2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO)
}

#' update lat positions, beta params, and accrate for non-negative normal data
#' @param Xitm1 data cube
#' @param dims vector of dims
#' @param tunex
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneBIO
#' @param ww vector of weights
#' @param t2
#' @param s2
#' @param g2
#' @param xiBin
#' @param xiBout
#' @param nuBin
#' @param nuBout
#' @param Cauchy
#' @param rnormsVec vector
#' @param rnormsBIO vector
#' @return returns list of:
#' \item{Xnew}{add desc}
#' \item{BinNew}{add desc}
#' \item{BoutNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
updateNonNegNorm <- function(Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, g2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO) {
    .Call('lsmdn_updateNonNegNorm', PACKAGE = 'lsmdn', Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, g2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO)
}

#' update lat positions, beta params, and accrate for binomial data
#' @param Xitm1 data cube
#' @param dims vector of dims
#' @param tunex
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneBIO
#' @param ww vector of weights
#' @param t2
#' @param s2
#' @param xiBin
#' @param xiBout
#' @param nuBin
#' @param nuBout
#' @param Cauchy
#' @param rnormsVec vector
#' @param rnormsBIO vector
#' @return returns list of:
#' \item{Xnew}{add desc}
#' \item{BinNew}{add desc}
#' \item{BoutNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
updatePoisson <- function(Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO) {
    .Call('lsmdn_updatePoisson', PACKAGE = 'lsmdn', Xitm1, dims, tunex, Y, BIN, BOUT, tuneBIO, ww, t2, s2, xiBin, xiBout, nuBin, nuBout, Cauchy, rnormsVec, rnormsBIO)
}

#' update weights and accprob for non-negative normal data
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @param g2
#' @return returns list of:
#' \item{wwNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
wAccProb_gaussian <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2) {
    .Call('lsmdn_wAccProb_gaussian', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2)
}

#' update weights and accprob for binomial data using log-likelihood approximation
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @param ELout array
#' @param ELin array
#' @param subseq matrix
#' @param degr array
#' @return returns list of:
#' \item{wwNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
wAccProb_llApprox <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, ELout, ELin, subseq, degr) {
    .Call('lsmdn_wAccProb_llApprox', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, ELout, ELin, subseq, degr)
}

#' update weights and accprob for non-negative normal data
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @param g2
#' @return returns list of:
#' \item{wwNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
wAccProb_nnn <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2) {
    .Call('lsmdn_wAccProb_nnn', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2)
}

#' update weights and accprob for binomial data
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @return returns list of:
#' \item{wwNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
wAccProb <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew) {
    .Call('lsmdn_wAccProb', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew)
}

#' update weights and accprob for non-negative normal data
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @param g2
#' @return returns list of:
#' \item{wwNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
wAccProbGaussian <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2) {
    .Call('lsmdn_wAccProbGaussian', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2)
}

#' update weights and accprob for non-negative normal data
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @param g2
#' @return returns list of:
#' \item{wwNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
wAccProbNonNegNormal <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2) {
    .Call('lsmdn_wAccProbNonNegNormal', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew, g2)
}

#' update weights and accprob for binomial data
#' @param X data cube
#' @param dims vector of dims
#' @param Y an n x n x T array of relational matrices, where the third dimension corresponds to different time periods
#' @param BIN betaIn value
#' @param BOUT betaOut value
#' @param tuneW
#' @param wwOld old vector of weights
#' @param wwNew new vector of weights
#' @return returns list of:
#' \item{wwNew}{add desc}
#' \item{AccRate}{add desc}
#' @export
wAccProbPoisson <- function(X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew) {
    .Call('lsmdn_wAccProbPoisson', PACKAGE = 'lsmdn', X, dims, Y, BIN, BOUT, tuneW, wwOld, wwNew)
}

