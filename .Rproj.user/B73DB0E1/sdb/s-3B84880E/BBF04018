{
    "collab_server" : "",
    "contents" : "#' LSMDN model fitting routine for longitudinal network data\n#' \n#' @param Y an n x n x T array of relational matrices, \n#' where the third dimension corresponds to different time periods.\n#' @param p number of latent dimensions\n#' @param family type of model to run. Options include 'normal', 'nonNegNormal', 'poisson', 'binomial'. \n#' @param llApprox logical indicating whether or not to utilize log-likelihood \n#' approximationg. Only available for binomial model types.\n#' @param missData logical indicating whether to impute missing data.\n#' @param N number of MCMC iterations.\n#' @param seed random seed\n#' @param burnin burnin\n#' @param progressBar include progress bar to show mcmc status\n#' @param saveResults save results to rda\n#' @param savePoints chain intervals to save at \n#' @param fileName \"lsmdn.rda\" or wtv you want, make sure to specify a path as well\n#' @param tuneX tuneX\n#' @param tuneBIO tuneBIO\n#' @param kappa kappa\n#' @param startVals Fitted result from previous model run.\n#' @param s2Init starting value for s2\n#' @param t2Init starting value for t2\n#' @param t2Init starting value for g2\n#' @param xLatPos starting actor positions in latent space\n#' @param betaInInit starting value for betaIn\n#' @param betaOutInit starting value for betaOut\n#' @param nuIn starting value for nuIn\n#' @param nuOut starting value for nuOut\n#' @param xiIn starting value for xiIn\n#' @param xiOut starting value for xiOut\n#' @param shapeT2 shape parameter for t2\n#' @param scaleT2 scale parameter for t2\n#' @param shapeS2 shape parameter for s2\n#' @param scaleS2 shape parameter for s2\n#' @param shapeG2 shape parameter for g2\n#' @param scaleG2 shape parameter for g2\n#' @usage lsmdn( Y, p=2, family='binomial', llApprox=FALSE, missData=FALSE, N=1000, seed=6886) \n#' @return returns list of starting values:\n#' \\item{w}{weights}\n#' \\item{X}{initial actor latent space positions calculated via GMDS}\n#' \\item{betaIn}{add desc}\n#' \\item{betaOut}{add desc}\n#' \\item{nuIn}{add desc}\n#' \\item{nuOut}{add desc}\n#' \\item{xiIn}{add desc}\n#' \\item{xiOut}{add desc}\n#' \\item{t2}{add desc}\n#' \\item{shapeT2}{add desc}\n#' \\item{scaleT2}{add desc}\n#' \\item{s2}{add desc}\n#' \\item{shapeS2}{add desc}\n#' \\item{scaleS2}{add desc}\n#' if llApprox=TRUE, also returns\n#' \\item{dInMax}{add desc}\n#' \\item{dOutMax}{add desc}\n#' \\item{n0}{add desc}\n#' \\item{elOut}{add desc}\n#' \\item{elIn}{add desc}\n#' \\item{degree}{add desc}\n#' \\item{edgeList}{add desc}\n#' @export\n#'\n\nlsmdn <- function(\n  Y, p=2, family, llApprox=FALSE, missData=FALSE, \n  N, seed=6886, burnin=round(N/10),\n  progressBar=TRUE,\n  saveResults=TRUE, savePoints=.10, fileName='lsmdnModel.rda',\n  tuneX=0.0075, tuneBIO=0.1, kappa=175000, \n  startVals=NULL, \n  s2Init=NULL, t2Init=NULL, g2Init=NULL, xLatPos=NULL, betaInInit=NULL, betaOutInit=NULL,\n  nuIn=NULL, nuOut=NULL, xiIn=NULL, xiOut=NULL, shapeT2=NULL, scaleT2=NULL, \n  shapeS2=NULL, scaleS2=NULL, shapeG2=NULL, scaleG2=NULL\n  ){\n\n  # add in some warnings\n  ## llApprox only works for binomial family\n  ## \n\n  #\n  set.seed(seed)  \n  n <- dim(Y)[1]\n  T <- dim(Y)[3]    \n\n  # get init values if no fitted values provided\n  if( is.null( startVals ) ){\n\n    tmp <- getStartingValues(\n      Y=Y, p=p, family=family, \n      llApprox=llApprox, missData=missData, \n      N=N, seed=seed\n      )\n\n    # unpack\n    Y<-tmp$Y ; w<-tmp$w ; X <-tmp$X ; betaIn<-tmp$betaIn ; betaOut<-tmp$betaOut ; \n    nuIn<-tmp$nuIn ; nuOut<-tmp$nuOut ; xiIn<-tmp$xiIn ; xiOut<-tmp$xiOut \n    t2<-tmp$t2 ; shapeT2<-tmp$shapeT2 ; scaleT2<-tmp$scaleT2\n    s2<-tmp$s2 ; shapeS2<-tmp$shapeS2 ; scaleS2<-tmp$scaleS2\n    n0<-tmp$n0 ; accRate<-tmp$accRate ; g2 <- NULL ; shapeG2 <- NULL ; scaleG2 <- NULL\n\n    if( family=='nonNegNormal' ){\n      g2<-tmp$g2 ; shapeG2<-tmp$shapeG2 ; scaleG2<-tmp$scaleG2 }\n\n    if( llApprox & family=='binomial' ){\n      dInMax<-tmp$dInMax ; dOutMax<-tmp$dOutMax ; elOut<-tmp$elOut ; elIn<-tmp$elIn\n      degree<-tmp$degree ; edgeList<-tmp$edgeList }\n\n    rm(tmp) # cleanup\n  }\n\n  if( !is.null( startVals ) ){\n    print('need to add code for unpacking')\n  }\n\n  # start mcmc\n  pb <- txtProgressBar(min=2,max=N,style=3)\n  system.time({\n  set.seed(seed)\n  for(it in 2:N){\n\n    #\n    RN <- rnorm(n*T*p)\n    RNBIO <- rnorm(2)\n\n    # Step 1\n    if(llApprox & family=='binomial'){\n      if(it%%100==0){\n        subseq <- matrix(0,n,n0)\n        for(i in 1:n){\n          nOnes <- round(length(edgeList[[ii]])/n+n0) # stratified sampling\n          if(length(edgeList[[i]])>0){ nOnes <- max(nOnes,1) }\n          subseq[i,1:nOnes] <- sample(edgeList[[i]],size=nOnes,replace=TRUE) # should replace be false?      \n          subseq[i,(nOnes+1):n0] <- sample(c(1:n)[-c(i,edgeList[[i]])],size=n0-nOnes,replace=TRUE)\n        } }\n\n      draws <- updateBinomLogLikeApprox(\n        X[[it-1]],c(n,p,T,dInMax,dOutMax),tuneX,Y, \n        betaIn[it-1],betaOut[it-1],tuneBIO,w[,it-1],\n        t2[it-1],s2[it-1],xiIn,xiOut,nuIn,\n        nuOut,Cauchy=0,RN,RNBIO,elOut,elIn,subseq,degree\n        ) }\n\n    if( !llApprox & family=='binomial' ){\n      draws <- updateBinom(\n        X[[it-1]],c(n,p,T,1),tuneX,Y, \n        betaIn[it-1],betaOut[it-1],tuneBIO,w[,it-1],\n        t2[it-1],s2[it-1],xiIn,xiOut,nuIn,\n        nuOut,Cauchy=0,RN,RNBIO\n        ) }\n\n    if( family=='nonNegNormal' ){\n      draws <- updateNonNegNorm(\n        X[[it-1]],c(n,p,T,1),tuneX,Y, \n        betaIn[it-1],betaOut[it-1],tuneBIO,w[,it-1],\n        t2[it-1],s2[it-1],g2[it-1],xiIn,xiOut,nuIn,\n        nuOut,Cauchy=0,RN,RNBIO\n        ) }\n\n    if( family=='gaussian' ){\n      draws <- updateGaussian(\n        X[[it-1]],c(n,p,T,1),tuneX,Y, \n        betaIn[it-1],betaOut[it-1],tuneBIO,w[,it-1],\n        t2[it-1],s2[it-1],g2[it-1],xiIn,xiOut,nuIn,\n        nuOut,Cauchy=0,RN,RNBIO\n        ) }\n\n    if( family=='poisson' ){\n      draws <- updatePoisson(\n        X[[it-1]],c(n,p,T,1),tuneX,Y, \n        betaIn[it-1],betaOut[it-1],tuneBIO,w[,it-1],\n        t2[it-1],s2[it-1],xiIn,xiOut,nuIn,\n        nuOut,Cauchy=0,RN,RNBIO\n        ) }\n\n    #\n    X[[it]] <- draws[[1]] ; betaIn[it] <- draws[[2]] ; betaOut[it] <- draws[[3]]\n    accRate <- accRate + draws[[4]] ; rm(draws)\n\n    #\n    if(it==burnin){\n      xIter0 <- t(X[[it]][,1,])\n      for(t in 2:T) xIter0 <- rbind(xIter0,t(X[[it]][,t,])) }\n\n    if(it>burnin){\n      xIterCentered <- t(X[[it]][,1,])\n      for(t in 2:T){ xIterCentered <- rbind(xIterCentered,t(X[[it]][,t,])) }\n      procr <- vegan::procrustes(X=xIter0,Y=xIterCentered,scale=FALSE)$Yrot\n      for(t in 1:T){ X[[it]][,t,] <- t(procr[((t-1)*n+1):(t*n),]) } }\n\n    if(it<N){ X[[it+1]] <- X[[it]] }\n\n    # Step 2\n    draws <- t2s2Parms(X[[it]], c(n,p,T,1), shapeT2, shapeS2, scaleT2, scaleS2)\n    t2[it] <- MCMCpack::rinvgamma(1,shape=draws[[1]],scale=draws[[2]])\n    s2[it] <- MCMCpack::rinvgamma(1,shape=draws[[3]],scale=draws[[4]]) ; rm(draws)\n\n    # Step 3\n    w[,it] <- MCMCpack::rdirichlet(1,alpha=kappa*w[,it-1])\n    if(llApprox & family=='binomial'){\n      draws <- wAccProb_llApprox(\n        X[[it]],c(n,p,T,dInMax,dOutMax),Y,\n        betaIn[it], betaOut[it], kappa, w[,it-1], w[it],\n        elOut, elIn, subseq, degree\n        ) }\n\n    if( !llApprox & family=='binomial' ){\n      draws <- wAccProb(\n        X[[it]],c(n,p,T,1),Y,\n        betaIn[it], betaOut[it], kappa, w[,it-1], w[,it]\n        ) }\n\n    if( family=='nonNegNormal' ){\n      draws <- wAccProbNonNegNormal(\n        X[[it]],c(n,p,T,1),Y,\n        betaIn[it], betaOut[it], kappa, w[,it-1], w[,it], g2[it-1]\n        ) }\n\n    if( family=='gaussian' ){\n      draws <- wAccProbGaussian(\n        X[[it]],c(n,p,T,1),Y,\n        betaIn[it], betaOut[it], kappa, w[,it-1], w[,it], g2[it-1]\n        ) }\n\n    if( family=='poisson' ){\n      draws <- wAccProbPoisson(\n        X[[it]],c(n,p,T,1),Y,\n        betaIn[it], betaOut[it], kappa, w[,it-1], w[,it]\n        ) }\n\n    w[,it] <- draws[[1]] ; accRate[3] <- accRate[3] + draws[[2]] ; rm(draws)\n\n    if( family=='nonNegNormal' ){\n      g2[it] <- MCMCpack::rinvgamma(1,shape=shapeG2,scale=scaleG2)\n      draws <- gammaAccProb(\n        X[[it]],c(n,p,T,1),Y, \n        betaIn[it],betaOut[it],shapeG2,scaleG2, \n        w[,it],g2[it-1], g2[it]\n        )\n      g2[it] <- draws[[1]] ; accRate[4] <- accRate[4] + draws[[2]] ; rm(draws)\n    }\n\n    if( family=='gaussian' ){\n      g2[it] <- MCMCpack::rinvgamma(1,shape=shapeG2,scale=scaleG2)\n      draws <- gammaAccProbGaussian(\n        X[[it]],c(n,p,T,1),Y, \n        betaIn[it],betaOut[it],shapeG2,scaleG2, \n        w[,it],g2[it-1], g2[it]\n        )\n      g2[it] <- draws[[1]] ; accRate[4] <- accRate[4] + draws[[2]] ; rm(draws)\n    }\n\n    # Step 4\n    if(missData){\n      for(t in 1:T){\n        if(family = 'binomial'){\n        Y <- imputeMissingBinomial(\n          X[[it]], c(n,p,T), MM=missing[[t]]-1, Y, Ttt=t,\n          BIN=betaIn[it], BOUT=betaOut[it], ww=w[,it]\n          )}\n        if(family = 'poisson'){\n        Y <- imputeMissingPoisson(\n          X[[it]], c(n,p,T), MM=missing[[t]]-1, Y, Ttt=t,\n          BIN=betaIn[it], BOUT=betaOut[it], ww=w[,it]\n          )}\n        if(family = 'gaussian'){\n        Y <- imputeMissingGaussian(\n          X[[it]], c(n,p,T), MM=missing[[t]]-1, Y, Ttt=t,\n          BIN=betaIn[it], BOUT=betaOut[it], ww=w[,it], g2 = g2[it]\n          )}\n\n\n\n      }\n    }\n\n    # save results\n    if(it > burnin){\n      if(saveResults){\n      if( it %in% round(quantile(1:(N-burnin), probs=seq(0,1,savePoints))[-1] ) ){\n        result <- list( Y=Y, X=X, p=p, betaIn=betaIn, betaOut=betaOut, t2=t2, s2=s2, g2=g2,\n          shapeT2=shapeT2, shapeS2=shapeS2, scaleT2=scaleT2, scaleS2=scaleS2,\n          shapeG2=shapeG2, scaleG2=scaleG2, nuIn=nuIn, nuOut=nuOut,\n          xiIn=xiIn, xiOut=xiOut, w=w, accRate=accRate )\n        save( result , file=fileName ) ; rm(result)\n      }\n      }      \n    } \n\n  if(progressBar){ setTxtProgressBar(pb,it) }\n  } # end mcmc\n  close(pb)\n  })\n\n  # output\n  result <- list(Y=Y, X=X, p=p, betaIn=betaIn, betaOut=betaOut, t2=t2, s2=s2, g2=g2, \n    shapeT2=shapeT2, shapeS2=shapeS2, scaleT2=scaleT2, scaleS2=scaleS2,\n    shapeG2=shapeG2, scaleG2=scaleG2, nuIn=nuIn, nuOut=nuOut,\n    xiIn=xiIn, xiOut=xiOut, w=w, accRate=accRate )\n  return( result )\n\n} # end function\n",
    "created" : 1481294355694.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1098812941",
    "id" : "BBF04018",
    "lastKnownWriteTime" : 1481565895,
    "last_content_update" : 1481565895,
    "path" : "~/Documents/lsmdn/R/lsmdn.R",
    "project_path" : "R/lsmdn.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}