{
    "collab_server" : "",
    "contents" : "rm(list = ls())\nload(\"Data/allyArray.rda\")\nhead(allyarray)\ndim(allyarray)\nY = allyarray\n\nfor(i in list.files(\"R\")){\n  source(paste(\"R/\",i, sep = \"\"))\n}\n\nfor(i in list.files(\"src\")){\n  source(paste(\"src/\",i, sep = \"\"))\n}####\nif(Sys.info()['user']=='janus829' | Sys.info()['user']=='s7m'){\n  source('~/Research/NetworkEvolution/Code/setup.R') }\n\nif(Sys.info()['user']=='maxgallop'){\n  source('~/Documents/NetworkEvolution/Code/setup.R') }\n\nif(Sys.info()['user']=='cassydorff'){\n  source('~/ProjectsGit/Research/nothingbutnet/NetworkEvolution/Code/setup.R') }  \n####  \n\n####\n# choose dataset\nload(paste0(inPath, 'matlCoop.rda'))\nY = events$'all' ; outFileName = paste0(outPath, 'lsmdn_matlCoop_all_test.rda')\n####\n\n####\n# run model\n# install from git\nlibrary(lsmdn)\n\ntest = lsmdn(Y, p=2, family='nonNegNormal', \n             llApprox=FALSE, \n             missData=FALSE, \n             N=1000, seed=6886,\n             savePoints=.25, fileName=outFileName\n)\n####\nlsmdn()\n###\n###Set the following parameters\n###\n\n#Number of MCMC iterations\nN=1000 \n#Dimension of the Euclidean latent space\np=2\n#Use log likelihood approximation (BOOLEAN)?\n#If TRUE, how large a subsample n0?\nllApprox = FALSE\nif(llApprox) n0 = 100\n#Are there missing edges?\nMissData = FALSE\n#If TRUE, construct Missing: Missing[[tt]]= c(1,2,3) => at time tt we have no row data on actors 1,2&3 \nif(MissData){\n  Missing <- list() #Enter as list manually, or if NAs are in data run the following:\n  temp = which(is.na(Y),arr.ind=TRUE)\n  for(tt in 1:dim(Y)[3]){\n    Missing[[tt]] = unique(temp[which(temp[,3]==tt),1])\n  }\n  Y[temp] = 0;rm(temp)\n}\n\n#MCMC tuning parameters\ntuneX <-   0.0075\ntuneBIO <- 0.1\nKappa <-   175000\nburnin = round(N/10)\n\n# Load pkgs and functions\nlsmdnPkgs = c('igraph', 'MCMCpack', 'inline',\n              'RcppArmadillo','vegan')\nloadPkg(lsmdnPkgs)\nsource(paste0(rFuncs, \"functions_NNC.R\"))\nsource(paste0(rFuncs, \"initialize_NNC.R\"))\n\n\n###\n###Run MCMC\n###\npb <- txtProgressBar(min=2,max=N,style=3)\nsystem.time({\n  set.seed(6886)\n  for(it in 2:N){\n    \n    RN <- rnorm(n*TT*p)\n    RNBIO <- rnorm(2)\n    if(llApprox){\n      if(it%%100==0){\n        SUBSEQ = matrix(0,n,n0)\n        for(i in 1:n){\n          nOnes <- round(length(edgeList[[i]])/n*n0) #stratified sampling\n          if(length(edgeList[[i]])>0){ nOnes <- max(nOnes,1) }\n          SUBSEQ[i,1:nOnes] <- sample(edgeList[[i]],size=nOnes,replace=FALSE)\n          SUBSEQ[i,(nOnes+1):n0] <- sample(c(1:n)[-c(i,edgeList[[i]])],size=n0-nOnes,replace=FALSE)\n        }\n      }\n    }\n    if(llApprox){\n      Draws <- c.update2(X[[it-1]],c(n,p,TT,dinmax,doutmax),tuneX,Y,\n                         Bin[it-1],Bout[it-1],tuneBIO,w[,it-1],\n                         t2[it-1],s2[it-1],xiIn,xiOut,nuIn,\n                         nuOut,CAUCHY=0,RN,RNBIO,ELOUT,ELIN,SUBSEQ,DEGREE)\n    }else{\n      Draws <- c.update1(X[[it-1]],c(n,p,TT,1),tuneX,Y,\n                         Bin[it-1],Bout[it-1],tuneBIO,w[,it-1],\n                         t2[it-1],s2[it-1],xiIn,xiOut,nuIn,\n                         nuOut,CAUCHY=0,RN,RNBIO, g2[it-1])\n    }\n    X[[it]] <- Draws[[1]]\n    Bin[it] <- Draws[[2]]\n    Bout[it] <- Draws[[3]]\n    AccRate <- AccRate + Draws[[4]]\n    \n    if(it==burnin){\n      Xit0 <- t(X[[it]][,1,])\n      for(tt in 2:TT) Xit0 <- rbind(Xit0,t(X[[it]][,tt,]))\n    }\n    if(it>burnin){\n      XitCentered <- t(X[[it]][,1,])\n      for(tt in 2:TT) XitCentered <- rbind(XitCentered,t(X[[it]][,tt,]))\n      procr <- vegan::procrustes(X=Xit0,Y=XitCentered,scale=FALSE)$Yrot\n      for(tt in 1:TT){\n        X[[it]][,tt,] <- t(procr[((tt-1)*n+1):(tt*n),])\n      }\n    }\n    if(it < N) X[[it+1]] <- X[[it]]\n    \n    #------------------Step 2--------------------------------\n    Draws1 <- c.t2s2Parms(X[[it]],c(n,p,TT,1),shapeT2,\n                          shapeS2,scaleT2,scaleS2)\n    t2[it] <- rinvgamma(1,shape=Draws1[[1]],scale=Draws1[[2]])\n    s2[it] <- rinvgamma(1,shape=Draws1[[3]],scale=Draws1[[4]])\n    \n    #------------------Step 3--------------------------------\n    \n    w[,it] <- rdirichlet(1,alpha=Kappa*w[,it-1])\n    if(llApprox){\n      Draws2 <- c.WAccProb2(X[[it]],c(n,p,TT,dinmax,doutmax),Y,\n                            Bin[it],Bout[it],Kappa,w[,it-1],w[,it],\n                            ELOUT,ELIN,SUBSEQ,DEGREE)\n    }else{\n      Draws2 <- c.WAccProb1(X[[it]],c(n,p,TT,1),Y,\n                            Bin[it],Bout[it],Kappa,w[,it-1],w[,it], g2[it - 1])\n    }\n    w[,it] <- Draws2[[1]]\n    AccRate[3] <- AccRate[3] + Draws2[[2]]\n    \n    #------------------Step 3.5--------------------------------\n    g2[it] = rinvgamma(1,shape=shapeG2,scale=scaleG2)\n    Draws3 = c.GammaAccProb1(X[[it]],c(n,p,TT,1),Y,\n                             Bin[it],Bout[it],shapeG2,scaleG2,\n                             w[,it-1],g2[it - 1], g2[it])\n    g2[it] = Draws3[[1]]\n    AccRate[4] = AccRate[4] + Draws3[[2]]\n    #------------------Step 4--------------------------------\n    \n    if(MissData){\n      for(tt in 1:TT){\n        Y <- c.missing(X[[it]],c(n,p,TT),MMM=Missing[[tt]]-1,Y,Ttt=tt,\n                       BETAIN=Bin[it],BETAOUT=Bout[it],WW=w[,it])\n      }\n    }\n    \n    if(it%%1000==0) save.image(outFileName)\n    \n    setTxtProgressBar(pb,it)\n  }\n  close(pb)\n})\nAccRate[1:4]/(it-1)\n\ntest$X[[length(test$X)]][,1:4,10:11]\nX[[length(X)]][,1:4,10:11]\n\nsummary(AccRate[-c(1:3)]/(it-1))\nsummary(test$accRate[-c(1:3)]/(it-1))\n\n\nlsmdn(Y, family = \"binomial\", p = 2)\n ",
    "created" : 1481289640970.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "2775252023",
    "id" : "A92916E5",
    "lastKnownWriteTime" : 7795577508681678848,
    "last_content_update" : 1481303195878,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}