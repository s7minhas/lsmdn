{
    "collab_server" : "",
    "contents" : "#' Initial parameter values for lsmdn\n#' \n#' @param Y an n x n x T array of relational matrices, \n#' where the third dimension corresponds to different time periods.\n#' @param p number of latent dimensions\n#' @param family type of model to run. Options include 'normal', 'nonNegNormal', 'poisson', 'binomial'. \n#' @param llApprox logical indicating whether or not to utilize log-likelihood \n#' approximationg. Only available for binomial model types.\n#' @param missData logical indicating whether to impute missing data.\n#' @param s2Init starting value for s2\n#' @param t2Init starting value for t2\n#' @param xLatPos starting actor positions in latent space\n#' @param betaInInit starting value for betaIn\n#' @param betaOutInit starting value for betaOut\n#' @param nuIn starting value for nuIn\n#' @param nuOut starting value for nuOut\n#' @param xiIn starting value for xiIn\n#' @param xiOut starting value for xiOut\n#' @param shapeT2 shape parameter for t2\n#' @param scaleT2 scale parameter for t2\n#' @param shapeS2 shape parameter for s2\n#' @param scaleS2 shape parameter for s2\n#' @param N number of MCMC iterations.\n#' @param seed random seed\n#' @usage getStartingValues( Y, p=2, family='binomial', llApprox=FALSE, missData=FALSE, N=1000, seed=6886) \n#' @return returns list of starting values:\n#' \\item{w}{weights}\n#' \\item{X}{initial actor latent space positions calculated via GMDS}\n#' \\item{betaIn}{add desc}\n#' \\item{betaOut}{add desc}\n#' \\item{nuIn}{add desc}\n#' \\item{nuOut}{add desc}\n#' \\item{xiIn}{add desc}\n#' \\item{t2}{add desc}\n#' \\item{shapeT2}{add desc}\n#' \\item{scaleT2}{add desc}\n#' \\item{s2}{add desc}\n#' \\item{shapeS2}{add desc}\n#' \\item{scaleS2}{add desc}\n#' if llApprox=TRUE, also returns\n#' \\item{dInMax}{add desc}\n#' \\item{dOutMax}{add desc}\n#' \\item{n0}{add desc}\n#' \\item{elOut}{add desc}\n#' \\item{elIn}{add desc}\n#' \\item{degree}{add desc}\n#' \\item{edgeList}{add desc}\n#' @export\n#' \n\ngetStartingValues <- function(\n\tY, p, family, llApprox, missData, N, seed,\n\ts2Init=NULL, t2Init=NULL, xLatPos=NULL, betaInInit=NULL, betaOutInit=NULL,\n\tnuIn=NULL, nuOut=NULL, xiIn=NULL, xiOut=NULL, shapeT2=NULL, scaleT2=NULL, \n\tshapeS2=NULL, scaleS2=NULL, g2=NULL, shapeG2=NULL, scaleG2=NULL\n\t){\n\n\t# Starting values for parameters\n\tn <- dim(Y)[1]\n\tT <- dim(Y)[3]\t\t\n\tbetaOut <- betaIn <- numeric(N)\n\ts2 <- t2 <- numeric(N)\n\taccRate <- numeric(3+n*T)\n\tnames(accRate) <- c(\"betaIn\",\"betaOut\",\"weights\", paste(\"X\",rep(1:n,T),rep(1:T,each=n),sep=\",\"))\n\n\t# init values for missingness in Y\n\tif(missData){\n\t\ttmp = which(is.na(Y),arr.ind=TRUE)\n\t\tmissing <- lapply( 1:T, function(t){ return( unique(tmp[which(tmp[,3]==t),1]) ) } )\n\t\tY[tmp] = 0; rm(tmp)\t\t\t\t\t\n\t\tY <- initNetMissVals( Y, missing )\n\t}\n\n\t# Weights\n\tw <- initWeights(Y, N)\n\n\t# Initial latent space positions via Sarkar & Moore 2005\n\tX <- gmds( Y, w, p, family )\n\n\t# initial values for betaIn and betaOut\n\tif( family=='binomial' ){\n\t\ttmp <- initBetaInOut(Y, xLatPos=X[[1]], p=p, w=w)\n\t\tX[[1]] <- tmp$'xLatPos'\n\t\tbetaIn[1] <- tmp$'betaInInit'\n\t\tbetaOut[1] <- tmp$'betaOutInit'\n\t\trm(tmp)\n\t} else { # could condition this on dist\n\t\tX[[1]] <- X[[1]]/n\n\t\tbetaIn[1] <- 10\n\t\tbetaOut[1] <- 10\n\t}\n\n\t# Priors and further initializations\n\tnuIn <- betaIn[1]\n\tnuOut <- betaOut[1]\n\txiIn <- xiOut <- 100\n\n\t#Tau^2\n\tt2[1] <- sum(X[[1]][,1,]*X[[1]][,1,])/(n*p)\n\tshapeT2 <- 2.05\n\tscaleT2 <- (shapeT2-1)*t2[1]\n\n\t#Sigma^2\n\ts2[1] <- 0.001\n\tshapeS2 <- 9\n\tscaleS2 <- 1.5\t\n\n\t#Gamma^2\n\tif(family=='nonNegNormal'){\n\t\tg2 <- numeric(N)\n\t\tg2[1] <- 25\n\t\tshapeG2 <- 2.05\n\t\tscaleG2 <- (1.05)*25 }\n\n\t# init values for log-likelihood approximation subsampling\n\tif( llApprox & family=='binomial' ){\n\t\ttmp <- initLogLikeApprox(Y, n0, seed)\n\t\treturn( \n\t\t\tlist(\n\t\t\t\tY=Y, w=w, X=X, betaIn=betaIn, betaOut=betaOut, nuIn=nuIn, nuOut=nuOut,\n\t\t\t\txiIn=xiIn, xiOut=xiOut, t2=t2, shapeT2=shapeT2, scaleT2=scaleT2,\n\t\t\t\ts2=s2, shapeS2=shapeS2, scaleS2=scaleS2, \n\t\t\t\tdInMax=tmp$dInMax, dOutMax=tmp$dOutMax, n0=tmp$n0, \n\t\t\t\telOut=tmp$elOut, elIn=tmp$elIn, degree=tmp$degree,\n\t\t\t\tedgeList=tmp$edgeList, accRate=tmp$accRate\n\t\t\t\t)\n\t\t\t)\n\t} else { # could condition this on dist\n\t\treturn(\n\t\t\tlist(\n\t\t\t\tY=Y, w=w, X=X, betaIn=betaIn, betaOut=betaOut, nuIn=nuIn, nuOut=nuOut,\n\t\t\t\txiIn=xiIn, xiOut=xiOut,\n\t\t\t\tt2=t2, shapeT2=shapeT2, scaleT2=scaleT2,\n\t\t\t\ts2=s2, shapeS2=shapeS2, scaleS2=scaleS2, \n\t\t\t\tg2=g2, shapeG2=shapeG2, scaleG2=scaleG2, \n\t\t\t\taccRate=accRate\n\t\t\t\t)\n\t\t\t)\n\t}\n\n}\n\n",
    "created" : 1481304029597.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "814264805",
    "id" : "98F453F2",
    "lastKnownWriteTime" : 1481300859,
    "last_content_update" : 1481300859,
    "path" : "~/Documents/lsmdn/R/getStartingValues.R",
    "project_path" : "R/getStartingValues.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}